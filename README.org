#+begin_center
*Vulkan is an API for graphics and compute hardware*
不仅仅用于图形渲染，还可用于计算
#+end_center

* Mac 下载安装 Vulkan SDK:
1. 从 lunarg 下载 [[https://vulkan.lunarg.com/home/welcome]] Vulkan SDK 的 MacOS 版本， Mac/iOS 下的 Vulkan 并非原生实现，而是通过 *MoltenVK* [[https://github.com/KhronosGroup/MoltenVK]]  作为中间层调用 Metal 来实现的。
2. 下载 Vulkan SDK 后，将它解压到一个合适的位置。 *Vulkan SDK 的 MacOS 版，已经内置了编译好的 MoltenVK。*
3. 然后在 ~/.bash_profile 文件中设置下面这些环境变变量。详见 [[https://vulkan.lunarg.com/doc/sdk/1.1.92.1/mac/getting_started.html]]
   #+begin_src sh
# 把 VULKAN_SDK 设置为 SDK 解压后里面 macOS 目录的地址。
export VULKAN_SDK=/Users/monty/STUDY/vulkansdk-macos-1.1.101.0/macOS

export VK_ICD_FILENAMES=$VULKAN_SDK/etc/vulkan/icd.d/MoltenVK_icd.json
export VK_LAYER_PATH=$VULKAN_SDK/etc/vulkan/explicit_layer.d

export DYLD_LIBRARY_PATH=$VULKAN_SDK/lib:$DYLD_LIBRARY_PATHH
export PATH=$PATH:$VULKAN_SDK/bin
   #+end_src
   - 运行 $VULKAN_SDK/bin 目录里的命令行程序 vulkaninfo 确认配置正确
   #+begin_src sh
monty$  cd $VULKAN_SDK/bin
monty$  vulkaninfo
   #+end_src


** 安装 GLFW
Vulkan 是一个平台无关的图形 API，它没有包含任何用于创建窗口的功能。为了跨平台和避免陷入 Win32 的窗口细节中去，我们使用 *GLFW* [[https://github.com/glfw/glfw]] 库来完成窗口相关操作，GLFW 库支持 Windows，Linux 和 MacOS。当然，还有其它一些库可以完成类似功能，比如 SDL。但除了窗口相关处理，GLFW 库对于 Vulkan 的使用还有其它一些优点。读者可以再 GLFW 的官方网站上免费下载到最新版本的 GLFW 库。

#+begin_src sh
$ brew install glfw3   #/usr/local/Cellar/ 目录下会多出来一个 glfw 的文件夹，相关的文件都在这个里面。
#+end_src


** 安装 GLM

Vulkan 没有包含线性代数库，我们需要自己找一个。GLM 就是一个我们需要的线性代数库，它经常和 Vulkan 和 OpenGL 一块使用。GLM 是一个只有头文件的库，我们只需要下载它的最新版，然后将它放在一个合适的位置，就可以通过包含头文件的方式使用它。
#+begin_src sh
brew install glm
#+end_src

** 在 CMakeLists.txt 文件里 设置 GLFW 和 VULKAN 头文件和链接库的路径：
参考这里设置 [[https://zhuanlan.zhihu.com/p/45528705][CMakeLists.txt]]

#+begin_src sh

# 通过$ENV{VULKAN_SDK} 引用在 ~/.bash_profile 里设置的环境变量 VULKAN_SDK
INCLUDE_DIRECTORIES("/usr/local/include")   #brew 安装头文件的目录 /usr/local/include, 包括 GLFW 和 GLM 的头文件
INCLUDE_DIRECTORIES("$ENV{VULKAN_SDK}/include")   # VULKAN 的头文件

LINK_LIBRARIES("/usr/local/lib/libglfw.3.3.dylib")  # GLFW 的动态链接库。brew 安装链接库的目录 /usr/local/lib
LINK_LIBRARIES("$ENV{VULKAN_SDK}/lib/libvulkan.1.dylib")  # vulkan 的动态链接库
LINK_LIBRARIES("$ENV{VULKAN_SDK}/lib/libvulkan.1.1.101.dylib")  #

#+end_src



** 编译运行 cmake build
至此, 你已经完成了基本项目的构建, 可以随意修改代码, 只要运行
#+begin_src sh
mkdir build   # 如果没有 build 目录，就先创建一个。
cd build

cmake ..  #生成 Makefile

make   #编译

#+end_src
就可以生成可执行文件了.

** Xcode 使用 Vulkan SDK 的开发环境配置，可以参考 *Vulkan Tutorial* 这本书中的设置 [[https://vulkan-tutorial.com/Development_environment#page_MacOS ]]


* Vulkan vs OpenGL
在有一些场景中，我们将观察到，OpenGL 和 Vulkan 之间在性能方面没有任何差别。 如果不需要多线程化，或应用不是 *CPU 密集型* （渲染的场景不太复杂），使用 OpenGL 即可，而且使用 Vulkan  不会实现性能提升 （但可能会 *降低功耗， 这对移动设备至关重要* ）。 但如果我们想最大限度地发挥图形硬件的功能，Vulkan 将是最佳选择。


* Vulkan 初始化流程 ：

1) vkCreateInstance()： VkInstanceCreateInfo +  VkApplicationInfo  创建实例
2) vkCreateDebugUtilsMessengerEXT：VK_LAYER_KHRONOS_validation默认在终端输出所有验证层的调试信息。启用实例扩展VK_EXT_debug_utils后， 自定义一个回调函数，输出我们感兴趣的信息。
3) glfwCreateWindowSurface：窗口 surface 需要在 instance 被创建后立即被创建，因为它实际上会影响物理设备的选择。

4) vkEnumeratePhysicalDevices() -> vkGetPhysicalDeviceQueueFamilyProperties() 根据合适的队列簇，选择物理设备, 为了要在窗口中显示图片，队列就要支持绘制和呈现，也就是：VK_QUEUE_GRAPHICS_BIT  和 vkGetPhysicalDeviceSurfaceSupportKHR
5) vkCreateDevice(): VkDeviceCreateInfo + VkDeviceQueueCreateInfo  创建逻辑设备、队列随着逻辑设备的创建而自动创建。

6) vkCreateSwapchainKHR()
7) vkCreateImageView(): 为了使用 VkImage,不管是在 SwapChain 还是在 Pipeline 中，都必须先创建 VkImageView, 它是 image 的一个 view，描述了我们如何访问 image、访问 image 的哪一部分等。
8) : vkCreateShaderModule() 在 Vulkan 中，图形管线几乎完全不允许进行动态设置，如果我们 想使用其它着色器，绑定其它帧缓冲，以及改变混合函数，都需要重新创 建管线。这就迫使我们必须提前创建所有我们需要使用的图形管线，虽然 这样看起来不太方便，但这给驱动程序带来了很大的优化空间。


#+ATTR_latex: :width 800
#+ATTR_HTML: :width 800
#+ATTR_ORG: :width 800
[[file:vulkan_pipeline.png]]


vkCreateInstance() → vkEnumeratePhysicalDevices() → vkCreateDevice()
vkEnumerateInstanceExtensionProperties()  // 为了在创建 instance 前检索支持的扩展 VkExtensionProperties

vkEnumerateInstanceLayerProperties 函数列出所有可以用的层
vkGetPhysicalDeviceFeatures
vkGetPhysicalDeviceProperties
vkGetPhysicalDeviceMemoryProperties


* example code
#+begin_src c++
vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()); // 创建实例前，先获取所有可以用于实例的扩展， 确认所有想要的扩展都是存在的。 然后再在VkInstanceCreateInfo中请求启用。
vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data()); // 创建实例前，获得所有可用实例层的验证, 确认所有想要的验证都是存在的， 再在VkInstanceCreateInfo中请求启用。 常用的是：VK_LAYER_KHRONOS_validation， 检查看看它是否存在， 它是一个大的验证层集合， 系统把所 有标准常用的验证层都融合在一起。
// getRequiredExtensions
glfwGetRequiredInstanceExtensions(&glfwExtensionCount); //  返回实例层用来创建surface的扩展列表，不但有基础的 VK_KHR_surface扩展， 还有针对特定操作系统扩展， macOS是 VK_MVK_macos_surface

// 实例层验证VK_LAYER_KHRONOS_validation默认在终端输出所有验证信息。可以启用实例扩展VK_EXT_debug_utils，然后自定义一个回调函数，就可只输出我们感兴趣的信息。
instance_createInfo.ppEnabledExtensionNames = extensions.data(); // 包含3个扩展 VK_KHR_surface, VK_MVK_macos_surface,  VK_EXT_debug_utils
instance_createInfo.ppEnabledLayerNames = validationLayers.data(); // VK_LAYER_KHRONOS_validation, 它是一个大的验证层集合，系统把所有标准常用的验证层，都融合在一起。
populateDebugMessengerCreateInfo(debugmsg_CreateInfo);  // 设置接收消息的回调函数pfnUserCallback，要输出的信息类型：warning, error...触发回调的事件类型：validation, performance...
instance_createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &debugmsg_CreateInfo; // 把pNext设为debugmsg_CreateInfo，vkCreateDebugUtilsMessengerEXT和 vkDestroyDebugUtilsMessengerEXT 就可共用下面的debugMessenger实例。
vkCreateInstance(&createInfo, nullptr, &instance) // 创建实例，实例层扩展和验证，要在VkInstanceCreateInfo实例创建信息中请求启用。

// setupDebugMessenger   生成函数vkCreateDebugUtilsMessengerEXT 和 vkDestroyDebugUtilsMessengerEXT 共用的VkDebugUtilsMessengerEXT实例
VkDebugUtilsMessengerEXT debugMessenger;
vkCreateDebugUtilsMessengerEXT(instance, &debugmsg_CreateInfo, nullptr, &debugMessenger); // 生成VkDebugUtilsMessengerEXT的实例。

// createSurface, 创建surface 需要在 instance 被创建后立即被创建，因为它实际上会影响物理设备的选择。
glfwCreateWindowSurface(instance, window, nullptr, &surface);

{// pickPhysicalDevice

    vkEnumeratePhysicalDevices(instance, &deviceCount, gpus.data()); // 枚举GPU
    { // isDeviceSuitable
        {
            vkGetPhysicalDeviceProperties(gup, &gpuProperties); // 查询物理设备的属性：支持的Vulkan API版本、设备名称和类型（集成或专用/独立GPU）、厂商ID和限制。
            vkGetPhysicalDeviceFeatures(gpu, &gpuFeatures); // 获取物理设备的可选特性，如：是否支持geometryShaderh或者tessellationShader，纹理压缩、64位浮点数和多视口渲染
            if(gpuProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && gpuFeatures.geometryShader);  // 是否独立显卡和支持几何着色器

            // findQueueFamilies,  为了要在窗口中显示图片，队列就要支持绘制和呈现，也就是：VK_QUEUE_GRAPHICS_BIT  和 vkGetPhysicalDeviceSurfaceSupportKHR
            vkGetPhysicalDeviceQueueFamilyProperties(gpu, &queueFamilyCount, queueFamilies.data());  //获取物理设备的 队列属性
            if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT);  // 现在我们将只查找支持图形命令的队列
            vkGetPhysicalDeviceSurfaceSupportKHR(gpu, i, surface, &presentSupport); // 以某个物理设备，的某个队列家族索引和surface为参数。 判断某个gpu、的某个队列家族、是否支持在这个surface显示present图像。
        }

        //checkDeviceExtensionSupport 获取莫个物理设备的所有 *逻辑设备扩展* 确认支持交换链扩展VK_KHR_swapchain， 要显示图片，这个逻辑设备扩展一定要
        vkEnumerateDeviceExtensionProperties(gpu, nullptr, &extensionCount, availableExtensions.data());

        { // querySwapChainSupport
            vkGetPhysicalDeviceSurfaceCapabilitiesKHR(gpu, surface, &details.capabilities); // 基础surface功能（交换链包含的image的最大\小数量，image的宽度和高度的最大\最小值）
            vkGetPhysicalDeviceSurfaceFormatsKHR(gpu, surface, &formatCount, details.formats.data()); // Surface格式（像素格式，颜色空间）
            vkGetPhysicalDeviceSurfacePresentModesKHR(gpu, surface, &presentModeCount, details.presentModes.data()); // 可用的presentation模式
        }
    }}

{// createLogicalDevice
    queueCreateInfo.queueFamilyIndex = selected_queuefamily_index;  // 想要启用的队列家族索引（通过它创建队列）, 队列在设备创建时会一同自动创建。
    queueCreateInfo.queueCount = 1; //我们希望在特定队列家族中启用的队列数量
    device_createInfo.pQueueCreateInfos = queueCreateInfos.data();
    createInfo.pEnabledFeatures = &deviceFeatures; // 希望启用的 vkGetPhysicalDeviceFeatures 特性， 比如几何着色器。

    device_createInfo.ppEnabledExtensionNames = deviceExtensions.data(); // 启用交换链扩展VK_KHR_swapchain，显示图片这个逻辑设备扩展一定要
    vkCreateDevice(gpu, &device_createInfo, nullptr, &device);  // 队列随着逻辑设备的创建而自动创建

    vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue); // 从队列家族获取队列句柄，保存在graphicsQueue。因为我们只创建一个队列，用索引0即可。
    vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue);
}

{// createSwapChain
    VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
    VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
    VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);

    swapchain_createInfo.imageFormat = surfaceFormat.format;
    swapchain_createInfo.imageColorSpace = surfaceFormat.colorSpace;
    swapchain_createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; // imageUsage指明Swap Chain里的image我们拿来做什么，在本例中我们将直接对image进行渲染，这就意味着Image将被当做颜色附件使用(color attachment)。如果你想先渲染一个单独的图片然后再进行处理，那就应该使用VK_IMAGE_USAGE_TRANSFER_DST_BIT并使用内存转换操作将渲染好的image 转换到SwapChain里。
    swapchain_createInfo.presentMode = presentMode;


    vkCreateSwapchainKHR(device, &swapchain_createInfo, nullptr, &swapChain);
    vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data());
}
#+end_src


* 初始化过程涉及的对象

** 创建实例前，先确认所有想要的实例层扩展和验证是否都存在:
- 3个实例层扩展 VK_KHR_surface, VK_MVK_macos_surface,  VK_EXT_debug_utils
- 1个实例层验证 VK_LAYER_KHRONOS_validation

扩展有2类，实例层扩展和逻辑设备扩展。现在推荐使用实例层验证，逻辑设备层验证不推荐使用了。
- 实例扩展：就是创建实例时将要请求启用的扩展
  - vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data()) 创建实例前，先获取所有可以用于实例的扩展， 确认所有想要的扩展都是存在的。 然后再在VkInstanceCreateInfo中请求启用。
  - 如果在macOS、Win系统上，使用glfwGetRequiredInstanceExtensions(&glfwExtensionCount) 可以方便的返回实例层用来创建surface所需要的扩展列表，不但有基础的VK_KHR_surface扩展， 还有针对特定操作系统的扩展，macOS是 VK_MVK_macos_surface

- 实例层验证：vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data()); 在创建实例前，获得所有可用于实例层的验证, 确认所有想要的验证都是存在的， 然后再在VkInstanceCreateInfo中请求启用。
  - 实例层验证的作用：函数调用传递的参数是否符合规范、对象的创建和销毁是否有内存泄露、线程是否安全、记录每个函数调用并在标准设备上输出、分析函数调用和重播
  - 最常用的实例层验证是：VK_LAYER_KHRONOS_validation，它是一个大的验证层集合，系统把所有标准常用的验证层都融合在一起。 它默认在终端输出所有验证层的调试信息。 启用实例扩展 VK_EXT_debug_utils后， 定义一个回调函数，只输出我们感兴趣的信息。
    
- 逻辑设备扩展：就是在创建逻辑设备时请求启用的扩展。经常在选择合适的物理设备时，使用vkEnumerateDeviceExtensionProperties(gpu, nullptr, &extensionCount, availableExtensions.data())  在创建逻辑设备前，获取莫个物理设备的所有 *逻辑设备扩展* ： 确认我们想在逻辑设备中使用的扩展都是存在的， 比如检查是否支持交换链扩展 VK_KHR_swapchain， 然后再在VkDeviceCreateInfo中请求启用。
    
#+begin_src c++
vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());
glfwGetRequiredInstanceExtensions(&glfwExtensionCount); // 如果在macOS、Win系统上，这个方法可以方便的返回实例层用来创建surface所需要的扩展列表，不但有基础的VK_KHR_surface扩展， 还有针对特定操作系统的扩展，macOS是 VK_MVK_macos_surface
vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data()); //  在创建实例前，获得所有可用于实例层的验证, 确认所有想要的验证都是存在的， 然后再在VkInstanceCreateInfo中请求启用。
#+end_src
** 创建一个 VkInstance 对象
- 在instance_createInfo中启用3个实例层扩展、1个实例层验证；
- 把pNext设为debugmsg_CreateInfo， 让2个自定义函数vkCreateDebugUtilsMessengerEXT 和 vkDestroyDebugUtilsMessengerEXT 可以共用一个VkDebugUtilsMessengerEXT实例

物理设备可以简单的和GPU硬件对应起来。例如集成显卡对应一个物理设备，独立显卡RTX2080TI对应一个物理设备。一台电脑上经常有多个GPU硬件，例如集成显卡Intel(R) HD Graphics 630、独立显卡RTX2080TI、计算卡NVIDIA P106。

#+begin_src c++
// 实例层验证VK_LAYER_KHRONOS_validation默认在终端输出所有验证信息。可以启用实例扩展VK_EXT_debug_utils，然后自定义一个回调函数，就可只输出我们感兴趣的信息。
instance_createInfo.ppEnabledExtensionNames = extensions.data(); // 包含3个扩展 VK_KHR_surface, VK_MVK_macos_surface,  VK_EXT_debug_utils
instance_createInfo.ppEnabledLayerNames = validationLayers.data(); // VK_LAYER_KHRONOS_validation, 它是一个大的验证层集合，系统把所有标准常用的验证层，都融合在一起。

populateDebugMessengerCreateInfo(debugmsg_CreateInfo);  // 设置接收消息的回调函数pfnUserCallback，要输出的信息类型：warning, error...触发回调的事件类型：validation, performance...
instance_createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &debugmsg_CreateInfo; // 把pNext设为debugmsg_CreateInfo，vkCreateDebugUtilsMessengerEXT和 vkDestroyDebugUtilsMessengerEXT 就可以共用下面的debugMessenger实例。

vkCreateInstance(&createInfo, nullptr, &instance) // 创建实例，实例层扩展和验证，要在VkInstanceCreateInfo实例创建信息中请求启用。
#+end_src

** 创建VkDebugUtilsMessengerEXT实例
- 创建函数vkCreateDebugUtilsMessengerEXT 和 vkDestroyDebugUtilsMessengerEXT 共用的VkDebugUtilsMessengerEXT实例
#+begin_src c++
VkDebugUtilsMessengerEXT debugMessenger;
VkDebugUtilsMessengerCreateInfoEXT debugmsg_CreateInfo;

// populateDebugMessengerCreateInfo
debugmsg_CreateInfo.messageSeverity =  VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; //要输出的信息类型：warning, error...
debugmsg_CreateInfo.messageType =  VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; // 触发回调的事件类型：validation, performance...
debugmsg_CreateInfo.pfnUserCallback = debugCallback; //  设置接收消息的回调函数

vkCreateDebugUtilsMessengerEXT(instance, &debugmsg_CreateInfo, nullptr, &debugMessenger); // 生成VkDebugUtilsMessengerEXT的实例。
#+end_src

** 创建平面surface, 需要在instance被创建后立即被创建，因为这个surface会作为下面选择物理设备是否合适的一个条件
#+begin_src c++
// vkGetPhysicalDeviceSurfaceSupportKHR(gpu, i, surface, &presentSupport); 判断某个gpu、的某个队列家族、是否支持在这个surface显示present图像。
glfwCreateWindowSurface(instance, window, nullptr, &surface); // 创建surface
#+end_src

** 选择物理设备（VkPhysicalDevice）：队列支持绘制和显示 + 逻辑设备支持交换链扩展VK_KHR_swapchain
- 枚举GPU硬件，选取一个或多个物理设备。一个VkInstance可有多个VkPhysicalDevice， 一个VkPhysicalDevice可创建多个逻辑设备VkDevice。跨GPU的调用还未实现。
- 队列簇QueueFamily，如：RTX2080TI显卡有16个队列用于绘图、8个队列用于计算、1个队列用于CPU和GPU间的数据传输。Vulkan将这些专有的功能队列称之为簇， 每一簇里面又分别有不同数量的队列。
- queue的职责是收集命令（命令缓冲区）并将其分派给gpu执行。 队列从QueueFamily中分配，Vulkan中的操作最终提交到Queue来异步执行的。共有4种队列
  - VK_QUEUE_GRAPHICS_BIT：图形
  - VK_QUEUE_COMPUTE_BIT：计算
  - VK_QUEUE_TRANSFER_BIT：传送（复制等内存操作）
  - VK_QUEUE_SPARSE_BINDING_BIT：内存绑定操作，用于更新稀疏资源。
    - 在矩阵中，若数值为0的元素远远多于非0元素，并且非0元素分布没有规律时，则称该矩阵为 *稀疏矩阵* ；与之相反，若非0元素占大多数时，则称该矩阵为 *稠密矩阵* 。
    - *稀疏内存* 是一项特殊功能，可让您存储大型图像资源；图像在内存中的存储容量远大于实际的存储容量。 这种技术是将图像分解为图块，并仅加载适合应用程序逻辑的图块。

- 选取合适的物理设备， 主要是看某个gup的队列簇QueueFamily是否满足要求，比如，为了要在窗口中显示图片， *队列支持绘制和显示 + 逻辑设备也要支持交换链扩展*
  - 需要注意的是，支持绘制和呈现的队列不一定是同一个。
  - *VK_QUEUE_GRAPHICS_BIT* 队列支持绘制，也就是：queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT
  - *surface* 队列支持图片显示：vkGetPhysicalDeviceSurfaceSupportKHR(gpu, i, surface, &presentSupport); 判断某个gpu、的某个队列家族、是否支持在这个surface显示present图像。
  - *VK_KHR_swapchain* 逻辑设备支持交换链扩展： 通过vkEnumerateDeviceExtensionProperties(gpu, nullptr, &extensionCount, availableExtensions.data())查询逻辑设备是否支持交换链扩展。

#+begin_src c++
vkEnumeratePhysicalDevices(instance, &deviceCount, gpus.data()); // 枚举GPU
{ // isDeviceSuitable
    {
        vkGetPhysicalDeviceProperties(gup, &gpuProperties); // 查询物理设备的属性：支持的Vulkan API版本、设备名称和类型（集成或专用/独立GPU）、厂商ID和限制。
        vkGetPhysicalDeviceFeatures(gpu, &gpuFeatures); // 获取物理设备的可选特性，如：是否支持geometryShaderh或者tessellationShader，纹理压缩、64位浮点数和多视口渲染
        if(gpuProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU && gpuFeatures.geometryShader);  // 是否独立显卡和支持几何着色器

        // findQueueFamilies,  为了要在窗口中显示图片，队列就要支持绘制和呈现，也就是：VK_QUEUE_GRAPHICS_BIT  和 vkGetPhysicalDeviceSurfaceSupportKHR
        vkGetPhysicalDeviceQueueFamilyProperties(gpu, &queueFamilyCount, queueFamilies.data());  //获取物理设备的 队列属性
        if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT);  // 现在我们将只查找支持图形命令的队列
        vkGetPhysicalDeviceSurfaceSupportKHR(gpu, i, surface, &presentSupport); // 判断某个gpu、某个队列家族、是否支持在这个surface显示present图像。

        //checkDeviceExtensionSupport 获取莫个物理设备的所有 *逻辑设备扩展* 确认支持交换链扩展VK_KHR_swapchain， 要显示图片，这个逻辑实例扩展一定是要的。
        vkEnumerateDeviceExtensionProperties(gpu, nullptr, &extensionCount, availableExtensions.data());

        { // querySwapChainSupport
            vkGetPhysicalDeviceSurfaceCapabilitiesKHR(gpu, surface, &details.capabilities); // 基础surface功能（交换链包含的image的最大\小数量，image的宽度和高度的最大\最小值）
            vkGetPhysicalDeviceSurfaceFormatsKHR(gpu, surface, &formatCount, details.formats.data()); // Surface格式（像素格式，颜色空间）
            vkGetPhysicalDeviceSurfacePresentModesKHR(gpu, surface, &presentModeCount, details.presentModes.data()); // 可用的presentation模式
        }
    }

#+end_src


** 创建逻辑设备 VkDevice 。
- 为什么需要创建逻辑设备? 因为大多数时候我们不需要物理设备的全部功能，在不同的场景， 只会开启其中的部分功能。比如挖矿、视频解压等情况就不需要渲染簇； 要画面显示的应用就不需要Compute簇等等。

#+begin_src c++
queueCreateInfo.queueFamilyIndex = selected_queuefamily_index;  // 想要启用的队列家族索引（通过它创建队列）, 队列在设备创建时会一同自动创建。
queueCreateInfo.queueCount = 1; //我们希望在特定队列家族中启用的队列数量
device_createInfo.pQueueCreateInfos = queueCreateInfos.data();
createInfo.pEnabledFeatures = &deviceFeatures; // 希望启用的 vkGetPhysicalDeviceFeatures 特性， 比如几何着色器。

device_createInfo.ppEnabledExtensionNames = deviceExtensions.data(); // 启用交换链扩展VK_KHR_swapchain，显示图片这个逻辑设备扩展一定要
vkCreateDevice(gpu, &device_createInfo, nullptr, &device);  // 队列随着逻辑设备的创建而自动创建

vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue); // 从队列家族获取队列句柄，保存在graphicsQueue。因为我们只创建一个队列，用索引0即可。
vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue

#+end_src


** 创建一个窗口，窗口 surface 和交换链
- 窗口 *VkSurfaceKHR* ： 后缀 KHR 意思是这些对象是 Vulkan 扩展的一部分。除非你不想显示图形(比如你只想离屏渲染)，不然你还是需要创建一个窗口来显示的。Vulkan API 是完全的平台不可知论者，这就是我们需要用标准化 WSI（窗口系统接口）扩展与窗口管理器交互的原因。Surface 是对可渲染窗口的跨平台抽象，一般通过提供一个本地窗口句柄的方式来实例化，例如在 Windows 上提供的句柄是 HWND。幸运的是，GLFW 库可以帮助我们处理不同平台的窗口问题。

- 交换链 *VkSwapchainKHR* ：Vulkan 中没有 *默认帧缓冲区 default framebuffer* 的概念。交换链确保当窗口系统在显示一个图像时，应用程序可以准备下一个图像， 保证 image 完全渲染完毕后才能进行显示十分重要。每次我们想绘制一帧时， 我们请求交换链提供给我们一个用于渲染的 image，当这一帧完成绘制后，这个 image 返回到交换链，准备在某个时刻被屏幕消费，呈现到屏幕上。

- 如果支持交换链，会涉及3个扩展：两种源于实例层，另一个就是作用于逻辑设备层的交换链扩展： *VK_KHR_swapchain* 
  - 第一种是在实例层定义的 *VK_KHR_surface* 扩展。 它描述“平面”对象，即应用窗口的逻辑表现形式。 该扩展支持我们查看平面的不同参数（功能、支持的格式、大小）， 并查询特定物理设备是否支持交换链 （更确切的说，特定队列家族是否支持在特定平面上演示图像）。 这些信息非常实用，因为我们不想选择物理设备并尝试通过它创建 逻辑设备， 来了解它是否支持交换链。 该扩展还可定义破环此类平面的方法。
  - 第二种实例层扩展依赖于操作系统，*glfwgetrequiredinstanceextensionsll* 返回 *实例层* 用来创建surface的扩展列表，不但有基础的VK_KHR_surface扩展， 还有针对特定操作系统扩展：
    - Windows中称为 VK_KHR_win32_surface
    - Linux中称为 VK_KHR_xlib_surface 或 VK_KHR_xcb_surface
    - adnroid是 VK_KHR_android_surface
    - macOS是 VK_MVK_macos_surface
    - iOS是 VK_MVK_ios_surface



** VkImageView 和 VkFrameBuffer
- imageView 引用一个 image 将要被使用的特定部分，Framebuffer 其实就是一堆 VkImageView，framebuffer 引用 imageView ，把它当做 color 、depth 和 stencil 的目标使用。因为 swapchain 里可以有多个 image。
- Frame buffer 帧缓冲区封装了 color buffer image 和 depth buffer image。其中 color buffer image 为从 swap chain 获取的 image，frame buffer 的创建个数需要跟 swap chain 的 image 的数量对应.

** 创建渲染通道 Render pass，它标明渲染目标和用法
- render layer 是把不同的物体放到不同的 layer 层里去渲染，比如前景放到一层，背景放到一层，所以每个层里渲染出来的图像包括的物体的所有信息。比如物体的高光，颜色，反光，阴影等等都在一个层里。
- render passes.是指把一个物体的所有信息，分开来进行渲染，比如颜色 pass、高光 passes、环境光遮挡等等其他 passes。为什么我们要用不同的 pass 来渲染呢？在源头就将这些信息独立开来，这样在合成的时候我们就可以有更多的控制空间和选择余地了。

- Render pass 描述了在渲染阶段要使用的 image 类型、如何使用以及如何处理 image 的内容。请注意，Render pass 只是描述要使用的 image 类型，而 framebuffer( 通过绑定 image )才是要使用的 image 实体。
- VkRenderPass 由多个子 pass 组成。在简单的场景一般只有一个子 pass。子 pass 选择一些 attachment 作为颜色目标，另外一些作为深度和模版目标。如果你有多个子 pass，每个子 pass 将有不同的集合，一些用于输入，一些用于输出。

** 创建帧缓存，它引用渲染通道
color attachment 为从 swap chain 获取的 image，depth/stencil attachment 为 depth buffer 的 image。

** 构建图形管线 Graphics pipeline
- Graphics Pipeline 通过创建 VkPipeline 对象来建立。它描述了一些显卡 *不可编程部分* 的可配置状态(configurable state )，比如 viewport 的大小和 depth buffer 操作等，以及用 *VkShaderModule 表示的可编程部分* 。VkShaderModule 对象用着色器的字节码来创建。驱动需要知道哪些渲染目标将在 pipeline 中使用，而这些目标就是我们在 Render pass 中定义的 image。

- Vulkan 和现存的其他图形 API 最显著地区别就是：几乎所有不可编程部分的配置都要在 pipeline 创建前提前完成。这就意味着如果你想换一个着色器(shader)或者仅仅改变一些顶点的布局(vertex layout) ,那么你必须重新创建 pipeline 。这也意味着你必须提前创建很多 pipeline，来应对渲染过程中不同组合的配置。只有很少的一些配置你可以动态改变，比如 viewport 的大小和 celar 的颜色等。Pipeline 中所有的配置状态你必须显示的进行定义，比如，颜色混合就没有为你提供默认的配置。

** 申请命令缓存，为交换链的每个 image 记录绘制命令
- Vulkan中的命令要先记录到VkCommandBuffer中，然后才能提交到队列queue，由队列将这些作业提交给物理设备去执行。VkCommandBuffer并不是直接创建的，它的构建非常昂贵， 它从VkCommandPool 中分配出来。
- 创建 *Command Buffer* 的三个重要元素分别为 VkDescriptorSet（纹理和常量）、VkPipeline（着色器和状态）和VkBuffer（顶点数组）

** 渲染一帧：请求 image，提交正确的绘制命令缓存，将 image 返回到交换链



* Buffer和内存 & 数据传输
- 创建Buffer之前都要先申请分配相应的内存，因为无论是Texture、VertexBuffer、IndexBuffer或者UniformBuffer等等，其实都最终都是一段内存，因此Vulkan将这些资源都视为Buffer。创建Buffer 时就需要指定 Buffer的大小、用途、共享模式等等。
- 由于在GPU中需要内存对齐，因此我们的Buffer大小与实际内存可能并不一致。为了获取不同资源对应的内存对齐大小以及需要实际分配的内存大小，Vulkan提供了vkGetBufferMemoryRequirements函数供我们使用。分配好内存之后，就可以将 Buffer于内存绑定到一起。
- 高速缓存具有最高的访问速度。其次就是访问各自独占的存储，而最慢的就是访问共享内存了，当然对于CPU来说访问共享内存与自己独占的内存在性能是基本没有差异的。这里的性能差异主要是从GPU的角度来说的。因此我们肯定愿意将一些CPU或GPU专有 的数据首先考虑放在各自的独占存储中，其次需要多方来访问的数据就放在共享内存中。
- 说了这么废话，就是为了给数据传输做铺垫。对于UniformBuffer，我们可能更希望将它放置于共享内存中，对于Texture、Vertex、Index等等我们更希望将它们放置于GPU的独立内存中。因此，对于UniformBuffer， 我们只需要在共享内存或者高速缓存上面分配内存，绑定到Buffer。对于其它数据，我们则需要先在共享内存或者高速缓存上分配临时内存，绑定临时Buffer，然后将数据拷贝至于该块内存，最后则创建真正的Buffer以及在GPU上分配独立的内存，通过 Transfer Command将数据从共享内存或者高速缓存拷贝至GPU内存。


* 基本的Vulkan编程流程：
#+ATTR_latex: :width 800
#+ATTR_HTML: :width 800
#+ATTR_ORG: :width 800
[[file:vulkan_program_flow.jpg]]
